// ---------------------------------------------------------------------------------------------
//  Copyright (c) Microsoft Corporation. All rights reserved.
//  Licensed under the MIT License. See License.txt in the project root for license information.
// ---------------------------------------------------------------------------------------------

import { IFileSystem, AutoRest, create } from "autorest";
import { EventEmitter } from "@microsoft.azure/eventing";
import { TrackedFile } from "./tracked-file";
import { OpenApiDocumentManager } from "./document-manager";
import { From } from "linq-es2015";
import { FileUriToPath, NormalizeUri, ResolveUri, GetExtension } from '../lib/uri';
import { isDirectory, readdir } from '@microsoft.azure/async-io';
import * as path from 'path';
import os = require('os');
import fs = require('fs');
import { AutoRestCodeGenerationResult } from '../lib/interfaces'

/**
 * Represents a "configuration/root" for a folder (or single document)
 * 
 * The DocumentContext is an IFileSystem implementation required by AutoRest.
 */
export class DocumentContext extends EventEmitter implements IFileSystem {
  public autorest: Promise<AutoRest>;
  private _readyToRun: NodeJS.Timer | null = null;
  private _fileSubscriptions = new Map<TrackedFile, () => void>();
  public cancel: () => boolean = () => true;
  private _outputs = new Map<string, { type: string, content: string }>();

  /**
   * Filters and combines all outputs generated by AutoRest to retrieve the fully resolved and merged OpenAPI definition and its source map.
   */
  public get fullyResolvedAndMergedDefinition(): { openapiDefinition: any, openapiDefinitionMap: sourceMap.RawSourceMap } {
    const openapiDefinition = From(this._outputs.values()).Where(x => x.type === "swagger-document.json").Select(x => JSON.parse(x.content)).FirstOrDefault();
    const openapiDefinitionMap = From(this._outputs.values()).Where(x => x.type === "swagger-document.json.map").Select(x => JSON.parse(x.content)).FirstOrDefault();
    return {
      openapiDefinition: openapiDefinition,
      openapiDefinitionMap: openapiDefinitionMap
    };
  }

  public async generateCode(additionalConfig: any): Promise<string> {
    this.Manager.debug('Creating AutoRest instance to generate code');
    const codeGeneratorInstance = await create(this, this.configurationFile);

    codeGeneratorInstance.AddConfiguration({ "debug": true });
    codeGeneratorInstance.AddConfiguration({ "verbose": true });
    codeGeneratorInstance.AddConfiguration(additionalConfig);

    const opDirName: string = (this.configurationFile && fs.existsSync(this.configurationFile)) ?
      path.basename(path.dirname(this.configurationFile)) : 'out';

    // where to output the generated code (clear the directory before generating code)
    const opPath: string = path.join(os.tmpdir(), opDirName);
    codeGeneratorInstance.AddConfiguration({ "output-folder": opPath });

    this.Manager.listenForResults(codeGeneratorInstance);
    let genFiles = {};
    codeGeneratorInstance.GeneratedFile.Subscribe((_instance, artifact) => {
      genFiles[artifact.uri] = artifact.content;
    });
    return new Promise<string>((r, _j) => {
      codeGeneratorInstance.Process().finish.then(() => {
        const result: AutoRestCodeGenerationResult = {
          outputFolder: opPath,
          generatedFiles: genFiles
        };

        this.Manager.debug(`AutoRest successfully generated the code. Result object:\n ${JSON.stringify(result)}`);
        return r(JSON.stringify(result));
      });
    });
  }

  private async createAutoRest(): Promise<AutoRest> {
    const result = await create(this, this.configurationFile);
    result.AddConfiguration({ "output-artifact": ["swagger-document.json", "swagger-document.json.map"] });
    result.AddConfiguration({ "azure-validator": true });

    // debug and verbose messages are not sent by default.
    // by adding these, we can ensure vscode always get them (and it can decide if it shows them or not)
    // (this was the default before, but it's being changed)
    result.AddConfiguration({ "debug": true });
    result.AddConfiguration({ "verbose": true });

    this.Manager.listenForResults(result);
    result.GeneratedFile.Subscribe((_instance, artifact) => {
      this._outputs.set(artifact.uri, artifact);
    });
    result.Finished.Subscribe((_autorest, success) => {
      this.cancel = () => true;

      if (success != false) {
        this.FlushDiagnostics(true);
        this.ClearDiagnostics();
      }
      this.Manager.verbose(`AutoRest Process Finished with '${success}'.`);
    });
    return result;
  }

  constructor(public Manager: OpenApiDocumentManager, public RootUri: string, public configurationFile?: string) {
    super();
    this.RootUri = NormalizeUri(this.RootUri + "/");
    this.autorest = this.createAutoRest();
  }

  public Track(file: TrackedFile) {
    if (!this._fileSubscriptions.has(file)) {
      this._fileSubscriptions.set(file, file.Changed.Subscribe((_f, _isnull) => this.Activate()));
    }
  }

  public UnTrack(file: TrackedFile) {
    if (this._fileSubscriptions.has(file)) {
      this._fileSubscriptions.delete(file);
    }
  }

  public async Activate(): Promise<void> {
    // tell autorest that it's view needs to be re-created.
    this.Manager.verbose(`Invalidating Autorest view.`);
    (await this.autorest).Invalidate();

    // if there is a process() running, kill it. 
    this.cancel();

    // reacquire the config file.
    (await this.autorest).configFileOrFolderUri = await (await AutoRest).DetectConfigurationFile(this, this.RootUri);
    // (await this.autorest).AddConfiguration({ "azure-validator": true });

    // if autorest is about to restart the work, stop that
    // so we can push it out a bit more.
    if (this._readyToRun) {
      clearTimeout(this._readyToRun);
      this._readyToRun = null;
    }
    return await this.RunAutoRest();
  }

  private FlushDiagnostics(force?: boolean) {
    this.Manager.debug(`Flushing diagnostics.`);

    for (let each of this._fileSubscriptions.keys()) {
      each.FlushDiagnostics(force);
    }
  }

  private ClearDiagnostics() {
    this.Manager.debug(`Clearing diagnostics.`);

    for (let each of this._fileSubscriptions.keys()) {
      each.ClearDiagnostics();
    }
  }

  private RunAutoRest(): Promise<void> {
    this.Manager.verbose(`Queueing up Autorest to process ${this.RootUri}.`);

    return new Promise<void>((r, _j) => {
      // queue up the AutoRest restart
      this._readyToRun = setTimeout(async () => {
        this._readyToRun = null;

        const autorest = await this.autorest;
        this.Manager.debug(`Starting AutoRest Process().`);

        var process = autorest.Process();
        process.finish.then(() => {
          return r();
        });
        this.cancel = () => {
          // make sure this can't get called twice for the same process call. 
          this.cancel = () => true;

          // Shut it down.
          this.Manager.debug(`Cancelling AutoRest Process().`);
          process.cancel();

          this.FlushDiagnostics(true);
          this.ClearDiagnostics();
          return true;
        };
      }, 100);
    });
  }

  async EnumerateFileUris(folderUri: string): Promise<Array<string>> {
    folderUri = NormalizeUri(folderUri);
    if (folderUri && folderUri.startsWith("file:")) {
      const folderPath = FileUriToPath(folderUri);
      var isdir = await isDirectory(folderPath);
      const A = (await AutoRest);
      if (isdir) {
        const items = await readdir(folderPath);
        return From<string>(items).Where(each => A.IsConfigurationExtension(GetExtension(each))).Select(each => ResolveUri(folderUri, each)).ToArray();
      }
    }
    return [];
  }

  async ReadFile(fileUri: string): Promise<string> {
    fileUri = NormalizeUri(fileUri);
    let file = (await this.Manager.AcquireTrackedFile(fileUri));
    return await file.content;
  }
}
